\documentclass[letterpaper,12pt]{article}

\usepackage{amsmath,amsfonts,mathtools}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{float}

% For displaying code
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{orangered}{rgb}{1,0.27,0}

% Settings for displaying code
\lstset{%
  language=bash,
  aboveskip=3mm,
  belowskip=3mm,
  basicstyle={\small\ttfamily},
  commentstyle=\color{dkgreen},
  frame=single,
  numbers=none,
  numberstyle=\tiny\color{gray},
  stringstyle=\color{mauve},
  keywordstyle=\color{orangered},
  emphstyle=\color{blue},
  showstringspaces=false,
  otherkeywords={=, +, [, ], (, ), \{, \}, *},
  % bash commands from:
  %http://www.math.montana.edu/Rweb/Rhelp/00Index.html
  emph={addgroup,adduser,alias,
  ant,
  apropos,apt-get,aptitude,aspell,awk,
  basename,bash,bc,bg,break,builtin,bzip2,cal,case,cat,cd,cfdisk,chgrp,
  chkconfig,chmod,chown,chroot,cksum,clear,cmp,comm,command,continue,
  cp,cron,crontab,csplit,cut,date,dc,dd,ddrescue,declare,df,diff,diff3,
  dig,dir,dircolors,dirname,dirs,dmesg,du,echo,egrep,eject,enable,env,
  ethtool,eval,exec,exit,expand,expect,export,expr,false,fdformat,
  fdisk,fg,fgrep,file,find,fmt,fold,for,format,free,fsck,ftp,function,
  fuser,gawk,getopts,
  git,
  grep,groups,gzip,
  gunzip,
  ,hash,head,help,history,hostname,
  id,if,ifconfig,ifdown,ifup,import,install,
  java, java6, java_cur
  join,kill,killall,less,
  let,ln,local,locate,logname,logout,look,lpc,lpr,lprint,lprintd,
  lprintq,lprm,ls,lsof,make,man,mkdir,mkfifo,mkisofs,mknod,mmv,more,
  mount,mtools,mtr,mv,
  mysql,
  netstat,nice,nl,nohup,notify-send,
  noweb,noweave,
  nslookup,op,
  open,passwd,paste,pathchk,ping,pkill,popd,pr,printcap,printenv,
  printf,ps,pushd,pwd,quota,quotacheck,quotactl,ram,rcp,read,
  readarray,readonly,reboot,remsync,rename,renice,return,rev,rm,rmdir,
  rsync,scp,screen,sdiff,sed,select,seq,set,sftp,shift,shopt,shutdown,
  sleep,slocate,sort,source,split,ssh,strace,su,sudo,sum,
  svn, svn2git,
  symlink,sync,
  tail,tar,tee,test,time,times,top,touch,tr,traceroute,trap,true,
  tsort,tty,type,ulimit,umask,umount,unalias,uname,unexpand,uniq,
  units,
  unrar,
  unset,unshar,until,useradd,usermod,users,uudecode,uuencode,
  vdir,vi,vmstat,watch,wc,Wget,whereis,which,while,who,whoami,write,
  zcat, xdg, version},
}

% Display tildes nicely
\lstset{
    literate={~} {$\sim$}{1}
}

\newcommand*{\lstitem}[1]{
  \setbox0\hbox{\lstinline{#1}}
  \item[\usebox0]
}

% Personal definitions
\newcommand{\lra}{\ensuremath{\longrightarrow{}}}
\newcommand{\vect}[1]{\mathbf{#1}}
\renewcommand{\qedsymbol}{\rule{0.7em}{0.7em}}
\newcommand{\tabitem}{~~\llap{\textbullet}~~}

% Theorem commands
\newtheorem{lem}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}

% Set spacing
\setenumerate{itemsep=1.5pt,parsep=1.5pt,topsep=0.5pt}
\setlist{itemsep=1.5pt,parsep=1.5pt,leftmargin=1pt}
\setitemize{itemsep=1.5pt,parsep=1.5pt,topsep=0.5pt}

% set 1" margins on 8.5" x 11" paper
% top left is measured from 1", 1"
\topmargin       0in
\oddsidemargin   0in
\evensidemargin  0in
\headheight      0in
\headsep         0in
\topskip         0in
\textheight      9in
\textwidth       6.5in

\begin{document}
\title{Missing Semester of CS Notes}
\author{Sean Wu}
\date{\today}
\maketitle

\tableofcontents

\pagebreak

% set spacing
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\section{The Shell - Bash}

\subsection{Paths}

\begin{itemize}
 \item Cmd line arguments separated by whitespace
 \item Use quotes \lstinline{" "} or escape the space \lstinline{\ }

       \begin{description}
        \item[environment variable:] variable set whenever shell starts (not every run of shell)
       \end{description}

 \item ex. home dir, username, \lstinline{PATH} variable
 \item Comments in bash start with \lstinline{#}
\end{itemize}

\begin{lstlisting}
echo $PATH # all file paths that bash will search for programs
# OUTPUT: colon-separated list
\end{lstlisting}

\begin{itemize}
 \item Whenever name of program (ex. \lstinline{echo}) is typed, bash will search through this list in \lstinline{PATH} , looking in each directory for the program matching the command
\end{itemize}

\begin{lstlisting}
which echo # tells you where file for command is located (ex. echo)
\end{lstlisting}

\begin{description}
 \item[paths:] way to name location of file on computer
\end{description}

\begin{itemize}
 \item Paths separated by forward slashes \lstinline{/} for UNIX and backslashes \lstinline{\} for Windows
\end{itemize}

\begin{description}
 \item[/] root; top of file system
\end{description}

\begin{itemize}
 \item On UNIX, everything is under the root \lstinline{/} namespace
       \begin{itemize}
        \item i.e. all absolute paths start with \lstinline{/}
       \end{itemize}
 \item On Windows, there is one root for every partition
 \item ex. \lstinline{C:\}, \lstinline{D:\}
 \item i.e. separate file system path hierarchies for each drive
\end{itemize}

\begin{description}
 \item[absolute path:] fully determines location of file
 \item[relative path:] path relative to your current working directory
 \item[.] current directory
 \item[..] parent directory
 \item[\textasciitilde] home directory
 \item[-] directory you were just in
\end{description}

\subsection{Flags and Options}

\begin{itemize}
 \item Flags and options specified after the program name
 \item The short form is usually with single slashes \lstinline{-<char>} and the long form is usually with double dashes \lstinline{--<word>}
 \item ex. \lstinline{-v} and \lstinline{--version} tell you the version of the program
 \item ex. \lstinline{-h} and \lstinline{--help} give you a quick help guide for the program
 \item Running command with \lstinline{--help} flag gives you the \lstinline{usage} in the following format
\end{itemize}

\begin{lstlisting}
  usage: ls [OPTION] ... [FILE] ...
  # [] means optional
  # ... means 1 or more of the previous thing
\end{lstlisting}

\begin{description}
 \item[flag:] doesn't take a value (usually)
 \item[option:] takes a value (usually)
\end{description}

\subsection{File Permissions}
\begin{itemize}
 \item Get file permissions by running \lstinline{ls -a}
 \item Permissions specified in 3 groups of 3 (r, w, x)
       \begin{enumerate}
        \item 1st group of 3 permissions is for owner of file
        \item 2nd group of 3 permissions is for the group of people owning the file
        \item 3rd group of 3 permissions is for everyone else
       \end{enumerate}
 \item Note: if you have write access on a file but read access on a directory, you cannot directly delete a file (can only empty it)
\end{itemize}

\textbf{For files:}
\begin{description}
 \item[-] don't have that permission
 \item[r] read access
 \item[w] write access
 \item[x] execute acess
\end{description}

\textbf{For folders:}
\begin{description}
 \item[-] don't have that permission
 \item[r] can see files inside directory
 \item[w] can rename, create, remove files
 \item[x] can search this directory (i.e. enter directory with \lstinline{cd})
\end{description}

\begin{description}
 \lstitem{chmod}: command to change file modes or Access Control Lists (i.e. change permissions)
\end{description}

\subsection{Deleting things}
\begin{description}
 \lstitem{rm}: removes a file
\end{description}

\begin{itemize}
 \item By default, \lstinline{rm} is \textbf{not} recursive on UNIX (i.e. cannot remove a directory)
 \item Add a \lstinline{-r} (recursive) flag to delete a directory
 \item Recursive delete removes everything under the path you give it
\end{itemize}

\begin{description}
 \lstitem{rmdir}: deletes a directory only if it is empty (a safe delete)
 \lstitem{cmd L}: clears terminal output to previous mark
 \lstitem{cmd K}: clears terminal to start
\end{description}

\subsection{Input and Output Streams}
\begin{itemize}
 \item Each program has 2 primary streams
       \begin{enumerate}
        \item Input stream: terminal by default
        \item Output stream: terminal by default
       \end{enumerate}
\end{itemize}

\begin{description}
 \lstitem{<}: rewire input of previous program to be the contents of this file on the right
 \lstitem{>}: rewire output of previous program into this file
 \lstitem{>>}: appends to the end of a file instead of overwriting
\end{description}

\begin{lstlisting}
  echo hello > hello.txt # writes string "hello" into file hello.txt
\end{lstlisting}

\begin{description}
 \lstitem{|}: a \textbf{pipe}; takes the output of program on left and makes it the input of the program on the right. \textbf{Input program does not know about output program and vice versa} . The programs just read and write to those spots.
\end{description}

\subsection{Root User (UNIX)}
\begin{itemize}
 \item Acts like admin user on Windows
 \item Has user id 0
 \item Has all permissions (Superuser)
\end{itemize}

\begin{description}
 \lstitem{sudo}: does the following command as superuser (root user)
 \item[kernel:] core of computer
       \lstitem{sysfs}: file system for kernel parameters of computer
\end{description}

\begin{itemize}
 \item Need to be admin to change kernel params of a computer
 \item Note: if using \lstinline{sudo} with pipes and redirects, \lstinline{sudo} only applies to one portion (because input and output programs don't know about each other)
\end{itemize}

\begin{description}
 \lstitem{\$} indicates that you are \textbf{not} running as root
 \lstitem{#} indicates that you are running as root
\end{description}

\begin{lstlisting}
  sudo echo 500 > brightness
  # does not work because brightness doesn't know about sudo
\end{lstlisting}

\begin{description}
 \lstitem{sudo su} gives you a shell as superuser (shell runs as root now)
 \lstitem{exit} allows you to exit out of superuser shell mode
\end{description}



\subsection{Misc. Helpful Commands}

\begin{description}
 \lstitem{man} gives you the manual pages for a program
 \lstitem{tail} gives you the last n lines of a file
\end{description}

\begin{lstlisting}
  tail -n5 # gives you the last 5 lines of a file
\end{lstlisting}

\begin{description}
 \lstitem{tee} writes to output and to terminal output
\end{description}

\begin{lstlisting}
  echo 1000 | sudo tee brightness # changes brightness
  # Note: this can be run without using superuser terminal
\end{lstlisting}

\begin{description}
 \lstitem{xdg-open} opens file (Linux)
 \lstitem{open} opens file (macOS)
\end{description}

\begin{description}
 \lstitem{source} reads and executes commands from the file specified as its argument in the current shell environment. Useful to load functions, variables and configuration files into shell scripts. It has a synonym in \lstinline{.} (period).
\end{description}

\begin{lstlisting}
  . filename [arguments]
  source filename [arguments]
\end{lstlisting}

\begin{lstlisting}
  # Note that ./ and source are not the same
  ./script
  # runs the script as an executable file, launching a new shell to
  # run it

  source script
  # reads and executes commands from filename in the current shell
  # environment
  # Note: ./script is not . script, but . script == source script
\end{lstlisting}

\subsection{Executable and UNIX Shebang}
\begin{description}
 \item[shebang: ] a character sequence involving \lstinline{#!} at the beginning of a script
\end{description}

\begin{itemize}
 \item A shebang \lstinline{#!} indicates that a file is an executable in UNIX
\end{itemize}

\begin{lstlisting}
  #!/bin/sh
  curl --head --silent https://missing.csail.mit.edu

  # First line indicates that program loader should run the
  # program /bin/sh, passing path/to/script (name of this file)
  # as the first argument.
\end{lstlisting}

\section{Shell Tools and Scripting}

\subsection{Defining Variables}

\begin{lstlisting}
  foo=bar # make var foo store the value bar
  echo $foo # OUTPUT: bar (the value of the foo)
  foo = bar # will not work bec of spaces
  # interprets as foo being the command with = and bar being args
  # Note: spaces reserved in bash for separating CLI args
\end{lstlisting}

\subsection{Defining Strings}

\begin{lstlisting}
  echo "Hello" # OUTPUT: Hello
  echo 'World' # OUTPUT: World (literal string for '')
  # Note: for literal strings, double "" and single quotes ''
  # are equivalent
\end{lstlisting}

\begin{lstlisting}
  echo "value is $foo" # OUTPUT: value is bar
  # variable $foo will be expanded in string for double quotes ""
  echo 'value is $foo' # OUTPUT: value is $foo
  # outputs string characters as displayed for single quotes ''
  # doesn't expand $foo
\end{lstlisting}

\subsection{Defining Functions}
\begin{lstlisting}
  # mcd.sh, a command to make a new dir and switch to it
  mcd () {
    mkdir -p "$1" # $1 is a special var for 1st CLI arg
    cd "$1"
  }
\end{lstlisting}

\begin{lstlisting}
  source mcd.sh # executes the script mcd.sh
  # new mcd function has been defined in shell
  # can now do
  mcd test
\end{lstlisting}

\subsection{Special Bash Variables}
\begin{description}
 \lstitem{$0}: name of script
 \lstitem{$1}: 1\textsuperscript{st} CLI arg
 \lstitem{$2 to $9}: 2\textsuperscript{nd} to 9\textsuperscript{th} arg
 \lstitem{$@}: expands to all args
 \lstitem{$#}: number of args given to current command
 \lstitem{$?}: gets error code from previous command
 \lstitem{$_}: last arg of previous command
 \lstitem{!!}: \textbf{bang bang}; Entire last command, including arguments. Usually used when you don't have permission (expands to previous command)
 \lstitem{$$}: Process Identification number for the current script
\end{description}

\begin{lstlisting}
  mkdir /mnt/new # Permission denied
  sudo !! # becomes equivalent to
  sudo mkdir /mnt/new
\end{lstlisting}

\subsection{Commands and Exit Codes}

\begin{itemize}
 \item Commands often return output using \lstinline{STDOUT}, errors through \lstinline{STDERR} and a Return Code to report errors in a more script friendly manner
 \item Return code or exit status are used by scripts/commands to communicate how execution went
\end{itemize}

\begin{description}
 \lstitem{0}: no issue; everything went OK
 \lstitem{1} or any number: error or issue with running command
\end{description}

\begin{lstlisting}
  echo "Hello" # OUTPUT: Hello
  echo $? # OUTPUT: 0
\end{lstlisting}

\begin{lstlisting}
  grep foobar mcd.sh # no output
  echo $? # OUTPUT: 1
  # bash tried to search for foobar string in mcd script but it
  # wasn't there (an error occurred)
\end{lstlisting}

\subsection{Boolean Logic}

\begin{itemize}
 \item Note: \lstinline{true} and \lstinline{false} always have \lstinline{0} and \lstinline{1} error codes
\end{itemize}

\begin{lstlisting}
  true
  echo $? # OUTPUT: 0
  false
  echo $? # OUTPUT: 1
\end{lstlisting}

\subsection{Logical Operators}
\begin{itemize}
 \item Exit codes can be used to conditionally execute commands using \lstinline{&&} and \lstinline{||}
\end{itemize}

\begin{description}
 \lstitem{||}: \textbf{OR operator}; executes 1\textsuperscript{st} commmand and if it fails, it executes the (i.e. 1st command did not have a 0 error code) 2\textsuperscript{nd} command
 \lstitem{&&}: \textbf{AND operator}; will only execute the 2\textsuperscript{nd} command if the 1\textsuperscript{st} one runs w/out error codes (i.e. 1st command had a 0 error code)
\end{description}

\begin{lstlisting}
  false || echo "oops fail" # OUTPUT: oops fail
  # bash ran 2nd command bec the 1st command has an error code of 1
  true || echo "Will not be printed" # no output
  # bash didn't run the 2nd command bec the 1st command has an
  # error code of 0
\end{lstlisting}

\begin{lstlisting}
  true && echo "Things went well" # OUTPUT: Things went well
  false && echo "This will not print"
\end{lstlisting}

\begin{description}
 \lstitem{;} can concatenate commands in the same line with a semicolon \lstinline{;}
\end{description}

\begin{lstlisting}
  false; echo "This always prints" # OUTPUT: This always prints
\end{lstlisting}

\subsection{Command Substitution}

\begin{itemize}
 \item Command substitution is used to get the output of a command as a variable
\end{itemize}

\begin{description}
 \lstitem{$(cmd)}: will execute \lstinline{cmd}, get the output of the command (stored in a \textbf{variable}) and substitute it in place.
\end{description}

\begin{lstlisting}
  foo=$(pwd) # gets output of pwd and stores it in foo variable
  echo $foo
\end{lstlisting}

\begin{lstlisting}
  echo "We are in $(pwd)" # OUTPUT: We are in /Users/admin/Documents
  # Note: $(pwd) is expanded because we are using double quotes ""
\end{lstlisting}

\subsection{Process Substitution}

\begin{itemize}
 \item Process substitution is useful when commands expect values to be passed by file instead of by STDIN
\end{itemize}

\begin{description}
 \lstitem{<(cmd)}: will execute \lstinline{cmd} and place the output in a \textbf{temporary file} and substitute the \lstinline{<()} with that file’s name
\end{description}

\begin{lstlisting}
  cat <(ls) <(ls ..) # OUTPUT: prints files in current dir and then
  # files in parent dir
  # ls-ing both current and parent directories and then storing
  #output in temp file using process substitution <(cmd)
  # cat then reads the output of the temp file
\end{lstlisting}

\begin{description}
 \lstitem{/dev/null}: special UNIX null register used to discard data that we do not care about
 \lstitem{>}: redirects standard output \lstinline{STDOUT}
 \lstitem{2>}: redirects standard error \lstinline{STDERR}
\end{description}

\begin{lstlisting}
  #!/bin/bash

  echo "Starting program at $(date)" # Date will be substituted

  echo "Running program $0 with $# arguments with pid $$"

  for file in $@; do
      grep foobar $file > /dev/null 2> /dev/null
      # When pattern is not found, grep has exit status 1
      # We redirect STDOUT and STDERR to a null register since we do
      # not care about them
      if [[ $? -ne 0 ]]; then
          echo "File $file does not have any foobar, adding one"
          echo "# foobar" >> "$file"
          # appends # foobar to end of file as a comment
      fi
  done
\end{lstlisting}

\begin{itemize}
 \item To see equality test flags, run \lstinline{man test}
 \item When performing comparisons in bash try to use double brackets \lstinline{[[ ]]} in favour of simple brackets \lstinline{[ ]}. Chances of making mistakes are lower although it won’t be portable to \lstinline{sh}
\end{itemize}

\subsection{Manipulating Files}
\begin{description}
 \lstitem{*} \textbf{globbing}; 0 or multiple character wildcard. When used with partial file name will expand to all files matching that pattern
 \lstitem{?} single character wildcard; only replaces 1 character (not 0 or more like with globbing)
 \lstitem{\{\}} used when you have a common substring that you want to expand automatically. Like for writing files with similar names but different extensions
\end{description}

\begin{lstlisting}
  ls *.sh # lists all files with .sh extension
\end{lstlisting}

\begin{lstlisting}
  # given files foo, foo1, foo2, foo10 and bar
  rm foo? # deletes foo1 and foo2
  rm foo* # deletes all except for bar
\end{lstlisting}

\begin{lstlisting}
  convert image.png image.jpg
  convert image.{png,jpg} # equivalent to above line
  # Remember: NO SPACES or else bash treats them as separate args
\end{lstlisting}

\begin{lstlisting}
  touch foo{,1,2,10}
  touch foo foo1 foo2 foo10
\end{lstlisting}

\begin{lstlisting}
  # can also combine everything and at multiple levels
  touch project{1,2}/src/test{1,2,3}.py

  # globbing techniques can also be combined like this
  mv *{.py,.sh} folder
  # Will move all *.py and *.sh files
\end{lstlisting}

\begin{description}
 \lstitem{..} expands into a range. \lstinline{1..5} \lra \lstinline{1,2,3,4,5}
\end{description}

\begin{lstlisting}
  touch {foo,bar}/{a..j}
  # expands into foo/a to foo/j and same with bar/a and bar/j
  diff <(ls foo) <(ls bar) # compares output of 2 ls commands
\end{lstlisting}

\subsection{Bash and Python Scripting}

\begin{description}
 \lstitem{#!} \textbf{shebang}; indicates that file is an executable and specifies which interpreter to use
\end{description}

\begin{itemize}
 \item Can add shebang to python to make it executable from the shell
\end{itemize}

\begin{lstlisting}
  #!/usr/local/bin/python
  # above line tells shell to use python as the interpreter
  import sys
  for arg in reversed(sys.argv[1:]):
    print(arg)
\end{lstlisting}

\begin{lstlisting}
  # can run above python file script.py as executable in shell
  ./script.py a b c # a,b,c are arguments passed to the script
\end{lstlisting}

\begin{lstlisting}
  # to avoid assuming where python is located, we can use the
  # env command in python file

  #!/usr/local/bin/env python
  # give python as argument to env command
  # output of env (location of python) becomes the interpreter
  # specified by the shebang
  import sys
  for arg in reversed(sys.argv[1:]):
    print(arg)
\end{lstlisting}

\begin{description}
 \lstitem{shellcheck}: useful CLI program to debug shell scripts; native shell doesn't give much useful error/debug statements
 \lstitem{tldr}: useful CLI program to get short documentation and examples for commands instead of using \lstinline{man}
\end{description}

\subsection{Shell Functions vs Scripts}
\begin{enumerate}
 \item Functions have to be in the same language as the shell, while scripts can be written in any language (ex. \lstinline{python})
       \begin{itemize}
        \item This is why including a shebang for scripts is important
       \end{itemize}
 \item Functions are loaded once when their definition is read. Scripts are loaded every time they are executed.
       \begin{itemize}
        \item This makes functions slightly faster to load but whenever you change them you will have to reload their definition
       \end{itemize}
 \item  Functions are executed in the current shell environment whereas scripts execute in their own process
       \begin{itemize}
        \item Thus, functions can modify environment variables, e.g. change your current directory, whereas scripts can’t.
       \end{itemize}
 \item Scripts will be passed by value environment variables that have been exported using \lstinline{export}
\end{enumerate}

\subsection{Finding Files}

\begin{description}
 \lstitem{find} UNIX CLI tool that recursively searches thru all the files that match a certain pattern
 \lstitem{locate} uses a database updated using \lstinline{cron} that is a a faster way of searching for files. To manually update database, run \lstinline{updatedb} (Linux) or \lstinline{sudo /usr/libexec/locate.updatedb} from root \lstinline{/} for MacOS
\end{description}

\begin{itemize}
 \item Tradeoff between \lstinline{find} and \lstinline{locate} is \textbf{speed vs freshness}
 \item Database may contain out of date info and needs to be updated
\end{itemize}

\begin{lstlisting}
  # Find all directories named src
  find . -name src -type d
  # Find all python files with a folder named test in their path
  find . -path '**/test/**/*.py' -type f
  # Find all files modified in the last day
  find . -mtime -1
  # Find all zip files with size in range 500k to 10M
  find . -size +500k -size -10M -name '*.tar.gz'
\end{lstlisting}

\begin{lstlisting}
  # Delete all files with .tmp extension
  find . -name '*.tmp' -exec rm {} \;
  # Find all PNG files and convert them to JPG
  find . -name '*.png' -exec convert {} {.}.jpg \;
\end{lstlisting}

\subsection{Searching Within Files}
\begin{description}
 \lstitem{grep} UNIX CLI tool used for searching or matching patterns from input text
 \lstitem{rg} \textbf{ripgrep}; a CLI tool that improves \lstinline{grep} by ignoring .git folders, using multi CPU support, etc.
\end{description}

Useful \lstinline{grep} and \lstinline{rg} flags
\begin{description}
 \lstitem{-C n} gives n lines of \textbf{C}ontext around the matched string
 \lstitem{-v} in\textbf{v}erts the match, i.e. print all lines that do not match the pattern
 \lstitem{-R} \textbf{R}ecursively go into directories and look for text files for the matching string.
\end{description}

\begin{lstlisting}
  # Find all python files where I used the requests library
  rg -t py 'import requests'
  # Find all files (including hidden files) without a shebang line
  rg -u --files-without-match "^#!"
  # Find all matches of foo and print the following 5 lines
  rg foo -A 5
  # Print statistics of matches (# of matched lines and files )
  rg --stats PATTERN
\end{lstlisting}

\subsection{Searching Previous Shell History}

\begin{description}
 \lstitem{up arrow}: goes through previous commands line by line. Inefficient for very old commands
 \lstitem{history}: command that prints out most recent commands
 \lstitem{ctrl r}: backwards search fo previous command history and execute in place. Repetitive typing of \lstinline{ctrl r}  will give you next previous command
\end{description}

\begin{lstlisting}
  history 1 # prints all results since beginning of time
  history 1 | grep convert
  # search all history for commands using convert
\end{lstlisting}


\subsection{Directory Structure}
\begin{description}
 \lstitem{tree}: pretty prints the directory structure
\end{description}

\section{Vim Text Editor}

\subsection{Vim philosohpy}
\begin{itemize}
 \item Vim is a \textbf{modal} editor (multiple operating modes for inserting text vs manipulating text)
 \item Vim interface is like a programming language: keystrokes are commands and these commands can be composable
 \item Vim avoids use of mouse and arrow keys to speed up workflow; all vim functionality available from keyboard
\end{itemize}

\subsection{Modal Editing}
\begin{itemize}
 \item Starts off in \textbf{normal mode}
\end{itemize}

\begin{description}
 \lstitem{<ESC>} \textbf{Normal}; for moving around a file and making edits
 \lstitem{i} \textbf{Insert}; for inserting text
 \lstitem{R} \textbf{Replace}; for replacing text
 \lstitem{v, V, or <C-v>} \textbf{Visual (plain, line, or block)}; for selecting blocks of text
 \lstitem{:} \textbf{Command-line}; for running a command
\end{description}


\begin{itemize}
 \item Note: \lstinline{<C-v>} means Ctrl-v
 \item Note: keystrokes have different meanings in different modes
 \item Vim shows current mode in bottom left
 \item Usually use normal or insert mode
\end{itemize}

\subsection{Vim buffers, tabs, and windows}
\begin{itemize}
 \item Vim maintains a set of open files called \textbf{buffers}
 \item A Vim session has a number of tabs, each with a number of windows (split panes)
 \item Each window shows only 1 buffer
 \item Note: a window is only a \textit{view}
 \item A given buffer may be open in \textit{multiple} windows (even in same tab)
\end{itemize}

\subsection{Command-line}
\begin{itemize}
 \item Enter command mode by typing \lstinline{:} in normal mode
\end{itemize}

\begin{description}
 \lstitem{:q} quit (close window)
 \lstitem{:qa} close all windows and quit
 \lstitem{:w} save ("write")
 \lstitem{:wq} save and quit
 \lstitem{:e {name of file}} open file for editing
 \lstitem{:ls} show open buffers
 \lstitem{:help {topic}} open help
 \lstitem{:help :w} opens help for \lstinline{:w} command
 \lstitem{:help w} opens help for the \lstinline{w} movement
\end{description}

\subsection{Movement Commands}
\begin{itemize}
 \item Spend most of the time in normal mode using movement commands (aka "nouns") to navigate the buffer
 \item Movements in Vim are also called “nouns”, because they refer to chunks of text.
\end{itemize}

\begin{description}
 \item[Basic movement] \lstinline{hjkl} (left, down, up, right)
 \item[Words] \lstinline{w} (next word) \lstinline{b} (beginning of word), \lstinline{e} (end of word)
 \item[Lines] \lstinline{0} (beginning of line), \lstinline{^} (first non-blank character), \lstinline{$} (end of line)
 \item{Screen} \lstinline{H} (top of screen), \lstinline{M} (middle of screen), \lstinline{L} (bottom of screen)
 \item[Scroll] \lstinline{Ctrl-u} (up), \lstinline{Ctrl-d} (down)
 \item[File] \lstinline{gg} (beginning of file), \lstinline{G} (end of file)
 \item[Line numbers] \lstinline|:{number}<CR>| or \lstinline|{number}G| (line {number})
 \item[Editing parentheses and brackets] \lstinline{\%} Jumps between matching brackets (),[]
 \item[Find] \lstinline|f{character}|, \lstinline|t{character}|, \lstinline|F{character}|, \lstinline|T{character}| find/to forward/backward {character} on the current line \lstinline{,} or \lstinline{;} for navigating matches
 \item[Search]: \lstinline|/{regex}|, \lstinline{n} or \lstinline{N} for navigating matches
\end{description}

\subsection{Text Selection}
\begin{itemize}
 \item Visual modes
       \begin{enumerate}
        \item Visual
        \item Visual Line
        \item Visual Block
       \end{enumerate}
 \item Can use movement keys in these modes to select text
\end{itemize}

\subsection{Editing}
\begin{itemize}
 \item Vim's editing commands are also called "verbs" because verbs act on nouns
\end{itemize}

\begin{description}
 \lstitem{i} enter insert mode
 \lstitem{o or O} insert line below/above
 \lstitem{d\{motion\}} delete {motion}
 \lstitem{dw} delete word
 \lstitem{d$} delete to end of line
 \lstitem{d0} delete to beginning of line
 \lstitem{c\{motion\}} change {motion}; like \lstinline|d{motion}| followed by \lstinline{i}
 \lstitem{cw} change word
 \lstitem{x} delete character (equal do \lstitem{dl})
 \lstitem{s} substitute character (equal to \lstitem{xi})
 \lstitem{u} undo
 \lstitem{<C-r>} redo
 \lstitem{y} to copy / “yank”
 \lstitem{p} paste
 \lstitem{\~} flips the case of a character
\end{description}

\subsection{Repeated Actions with Counts}
\begin{itemize}
 \item Can combine nouns (movement command) and verbs (editing command) with a count
 \item Performs a given action a number of times
\end{itemize}

\begin{description}
 \lstitem{3w} move 3 words forward
 \lstitem{5j} move 5 lines down
 \lstitem{7dw} delete 7 words
\end{description}

\begin{itemize}
 \item Note: repeating a character twice applies that command to a whole line
 \item ex. \lstinline{dd} deletes a whole line
\end{itemize}

\subsection{Modifiers}
\begin{itemize}
 \item Can use modifiers to change meaning of a noun (movment command)
 \item ex. the \lstinline{i} modifier means "inner" or "inside" and the \lstinline{a} modifier means "around"
\end{itemize}

\begin{description}
 \lstitem{ci(} change the contents inside the current pair of parentheses
 \lstitem{ci[} change the contents inside the current pair of square brackets
 \lstitem{da'} delete a single-quoted string, including the surrounding single quotes
\end{description}

\subsection{Search and Replace}
\begin{description}
 \lstitem{:s} substitute
 \lstitem{\%s/foo/bar/g} replace foo with bar globally in file
 \lstitem{\%s/\[.*\](\(.*\))/\1/g} replace named Markdown links with plain URLs
\end{description}

\subsection{Multiple Windows}
\begin{description}
 \lstitem{:sp or :vsp} to split windows
 \lstitem{:tabnew} new tab
\end{description}

\begin{itemize}
 \item Can have multiple views of the same buffer.
\end{itemize}

\section{Data Wrangling}
\begin{description}
 \lstitem{journalctl}: view system logs
 \lstitem{ssh}: access computers remotely through commmand-line
 \lstitem{sed}: stream editor; make changes to stream. Usually use it to run  replacement commands on input stream
 \lstitem{less}: pager to scroll through output and view data
\end{description}

\begin{itemize}
 \item Can specify which commands to run on server when using \lstinline{ssh} by using single quotes \lstinline{''}
\end{itemize}

\begin{lstlisting}
  # Read server logs to see who is trying to log in
  # This command uses pipes to stream a remote file through grep
  # on local computer
  ssh myserver journalctl | grep sshd

  # This does filtering on the server and then displays data locally
  # with the pager
  ssh myserver 'journalctl | grep sshd | grep "Disconnected from"'
   | less
\end{lstlisting}

\subsection{RegEx}

\begin{lstlisting}
  ssh myserver journalctl
   | grep sshd
   | grep "Disconnected from"
   | sed 's/.*Disconnected from //'
  # This uses the s substitution command for sed with regex (regular
  # expressions)
\end{lstlisting}

\begin{description}
 \lstitem{s/REGEX/Substitution/} \textbf{substitution} command in \lstinline{sed}, where \lstinline{REGEX} is the regular expression you want to search for and \lstinline{SUBSTITUTION} is the text you want to substitute matching text for
\end{description}

\begin{itemize}
 \item Regular expressions are usually surrounded by \lstinline{/}
 \item Note: to use \lstinline{sed} with modern regex (no escaping of characters with \lstinline{\}), use \lstinline{sed -E}
\end{itemize}

\begin{description}
 \lstitem{.} means “any single character” except newline
 \lstitem{*} zero or more of the preceding match
 \lstitem{+} one or more of the preceding match
 \lstitem{?} zero or one of the preceding pattern; i.e. prevents regex from greedy matching as many occurrences as possible
 \lstitem{[]} one of many characters (specified inside square brackets \lstinline{[]})
 \lstitem{[abc]} selects any one character of a, b, and c
 \lstitem{[^abc]} selects any character that is \textbf{not} abc. The use of \lstinline{^} in square brackets \lstinline{[^]} means to exclude those characters in the match
 \lstitem{-} used to specify a range of characters
 \lstitem{[0-9]} selects any one number between 0 and 9
 \lstitem{(RX1|RX2)} either something that matches \lstinline{RX1} or \lstinline{RX2}
 \lstitem{^} matches the start of the line
 \lstitem{$} matches the end of the line
\end{description}

\begin{lstlisting}
  /.*Disconnected from /
  # matches any text starting with any number of characters
  # (.*) followed by the literal string "Disconnected from "
\end{lstlisting}

\begin{itemize}
 \item Note: \lstinline{*} and \lstinline{+} are by default "greedy" (will match as many occurrences as possible)
 \item To avoid that, suffix \lstinline{*} and \lstinline{+}  with \lstinline{?} like \lstinline{*?} or \lstinline{+?} (not supported in \lstinline{sed})
 \item Recommended: use a regex debugger online to make sure the regex does what you want
 \item Recommended: use \lstinline{^} and \lstinline{$} to specify the beginning and end of the line to prevent users from doing weird stuff
\end{itemize}

\begin{lstlisting}
  | sed -E 's/.*Disconnected from (invalid |authenticating )?user
  .* [^ ]+ port [0-9]+( \[preauth\])?$//'
  # matches any text starting with any number of characters (.*)
  # followed by the literal string "Disconnected from "
  # then matches any of the user variants followed by matching any
  # single word ([^ ]+), i.e. any non-empty sequence of
  # nonspace characters, then the word "port" with some digits, then
  # possibly the suffix [preauth], and finally the end of the line
  # Note: square brackets [] are special characters in regex
  # so we have to escape them
\end{lstlisting}

\begin{itemize}
 \item Use \textbf{capture groups} in regex to store strings for use later
\end{itemize}

\begin{description}
 \lstitem{()} any text matched by a regex surrounded by parentheses is stored in a numbered capture group. Available for substitution as \lstinline{\1}, \lstinline{\2}, \lstinline{\3}, etc
\end{description}

\begin{lstlisting}
  | sed -E 's/.*Disconnected from (invalid |authenticating )?user
  (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
  # does same matching as before but replaces each line with
  # the 2nd capture group \2
  # i.e. any text after user (.*), which is the username
\end{lstlisting}

\subsection{Useful Data Wrangling Commands}
\begin{description}
 \lstitem{wc} wordcount program
 \lstitem{wc -l} gives number of lines
 \lstitem{sort} sorts lines of input (in ascending order by default)
 \lstitem{uniq} outputs the unique lines for a sorted list of lines
 \lstitem{uniq -c} outputs unique lines for a sorted list of lines with the number of occurrences
 \lstitem{sort -nk1,1} sorts numerically (\lstinline{n}), for a white space separated column (\lstinline{k}), starting and ending at the 1st column (\lstinline{1,1})
 \lstitem{awk} column based stream editor; operates on whitespaced separated columns
 \lstitem{paste} paste lines together with a delimiter
 \lstitem{bc} basic calculator; takes input from STDIN (use pipes)
 \lstitem{xargs} takes lines of input and turns them into arguments
 \lstitem{-} tells program to use STDIN or STDOUT instead of a given file; replaces a file argument (usually used with pipes)
\end{description}

\begin{lstlisting}
  ssh myserver journalctl
   | grep sshd
   | grep "Disconnected from"
   | sed -E 's/.*Disconnected from (invalid |authenticating )?user
    (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
   | sort | uniq -c

  # takes usernames from before and sorts them (ascending
  # alphabetically), but only keeps the unique ones and adds
  # a count of occurrences
\end{lstlisting}

\begin{lstlisting}
  ssh myserver journalctl
   | grep sshd
   | grep "Disconnected from"
   | sed -E 's/.*Disconnected from (invalid |authenticating )?user
    (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
   | sort | uniq -c
   | sort -nk1,1 | tail -n10

  # takes the alphabetically sorted list of unique usernames
  # then sorts them again numerically based on the number of
  # occurrences by using sort -nk1,1
  # i.e. sort by only the first whitespace-separated column up to
  # the 1st column
  # tail then gives the last ones (the most common ones since sort
  # is ascending)
\end{lstlisting}

\begin{lstlisting}
  rustup toolchain list | grep nightly | grep -vE "nightly-x86"
   | sed 's/-x86.*//' | xargs rustup toolchain uninstall
  # uses xargs to pass certain versions as arguments to the rust
  # uninstallation program
\end{lstlisting}


\begin{lstlisting}
  ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -
   | convert - -colorspace gray -
   | gzip
   | ssh mymachine 'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -'
  # pipes useful to binary data
  # here we used ffmpeg to capture webcam image, convert it
  # to grayscale, compress it, send it to a remote machine over SSH,
  # decompress it there, make a copy, and then display it locally
\end{lstlisting}

\section{Command-line Environment}

\subsection{Job Control and Processes}
\begin{itemize}
 \item The shell uses a UNIX communication mechanism called a \textbf{signal} to communicate info to a process
 \item When a process receives a signal, it stops its execution, deals with the signal, and potentially changes the flow of execution based on the info that the signal delivered
\end{itemize}

\begin{description}
 \lstitem{sleep} takes an integer argument specify the number of seconds that the process will "sleep"
 \lstitem{ctrl-C} \^{}C stops execution of a process  by sending a SIGINT signal to tell the process to stop itself. The process is then ended.
 \lstitem{ctrl-Z} \^{}Z suspends the terminal by sending the process a SIGTSTP signal. The process is then stopped and put in the background, but its execution can be continued later
 \lstitem{ctrl-\\} quits execution of a process by sending a SIGQUIT signal
 \lstitem{man signal} gives list of UNIX signals and their numbered identifiers
 \lstitem{kill -TERM <PID>} sends a SIGTERM signal to the process with process id \lstinline{<PID>} to ask process to exit gracefully
\end{description}

\subsection{Common Unix Signals}

\begin{description}
 \lstitem{SIGINT}: signal sent by terminal to \textit{interrupt} execution of a process (i.e. \textit{software interrupt})
 \lstitem{SIGQUIT}: signal sent by terminal to \textit{quit} execution of a program
 \lstitem{SIGHUP}: signal to indicate terminal \textit{hangup}
 \lstitem{SIGSTOP}: pauses execution of a process to \textit{stop}
 \lstitem{SIGTSTP}: sends a \textit{terminal stop} (i.e. the terminal's version of \lstinline{SIGSTOP})
 \lstitem{SIGCONT}: \textit{continues} execution of a stopped program at a later point in time
 \lstitem{SIGKILL}: causes a process to terminate \underline{immediately} (i.e. \textit{kill} the process). Unlike SIGINT, this signal cannot be caught or ignored because the receiving process cannot do any clean-up after receiving this signal
 \lstitem{SIGTERM}: a more generic signal to ask process to exit gracefully. Sent using \lstinline{kill} command
\end{description}

\begin{itemize}
 \item if there are still things running in your terminal when you close it, the program sends a SIGHUP to all processes to tel them to stop (i.e. had a hang-up in the command line communication)
 \item Can change the default behaviour of process upon receiving signals by using handlers in the program
\end{itemize}

\begin{description}
 \item[handler] captures signal and adds extra behaviour
 \item[orphan process] when a process has other small children processes that it started, using SIGKILL to kill the 1st parent process will leave the child process still running (but without the parent). May lead to weird behaviour.
\end{description}


\begin{lstlisting}[language=python]
  #!/usr/bin/env python
  import signal, time

  def handler(signum, time):
    print("\nI got a SIGINT, but I am not stopping")
    # handler captures SIGINT and ignores it
    # i.e no longer stops execution and continues running

  signal.signal(signal.SIGINT, handler)
  i = 0
  while True:
    time.sleep(.1)
    print("\r{}".format(i), end="")
    i += 1

  # to actually stop this program, we need to use a SIGQUIT signal
  # by typing ctrl-\
\end{lstlisting}

\begin{lstlisting}
  # if we run that program and send SIGINT twice, nothing happens
  # it only stops when we give it SIGQUIT

  $ python sigint.py
  24^C
  I got a SIGINT, but I am not stopping
  26^C
  I got a SIGINT, but I am not stopping
  30^\[1]    39913 quit       python sigint.py
\end{lstlisting}

\begin{itemize}
 \item \lstinline{SIGINT} is like a "user-initiated happy termination" while \lstinline{SIGQUIT} is like a "user-initiated unhappy termination" (both can be caught or ignored)
 \item \lstinline{SIGTERM} terminates the process, gracefully or not, but allows it a chance to clean up (can be caught or ignored)
 \item \lstinline{SIGKILL} kills the process immediately and is a last resort (process cannot catch signal or clean up)
\end{itemize}

\subsection{Pausing and Background Processes}
\begin{description}
 \lstitem{fg} continues a paused job in the foreground
 \lstitem{bg} continues a paused job in the background
 \lstitem{jobs} lists unfinished jobs associated with current terminal session
 \lstitem{pgrep} finds process id (PID) of running jobs
 \lstitem{nohup} a wrapper for a command to ignore \lstinline{SIGHUP}. Allows a process to continue running when shell closed (useful when working on remote machine in case you disconnect)
 \lstitem{disown} removes a process form the shell's job contorl and allows it to ignore \lstinline{SIGHUP}
\end{description}

\begin{itemize}
 \item Can refer to unfinished jobs using their pid or with a percent sign \% and their job number
 \item Can refer to last backgrounded job with \lstinline{$!} environment variable
 \item Adding an ampersand \& suffix in a command will run the command in the background (will still use STDOUT but will give you the prompt back)
 \item To background an already running program, you can do \lstinline{ctrl-Z} followed by \lstinline{bg}
 \item Note: backgrounded processes are still children processes of the terminal and will die if you close the terminal (terminal sends a \lstinline{SIGHUP} signal)
\end{itemize}

\begin{lstlisting}
  # example of jobs and foreground/background processes
  $ sleep 1000
  ^Z
  [1]  + 18653 suspended  sleep 1000

  $ nohup sleep 2000 &
  [2] 18745
  appending output to nohup.out

  $ jobs
  [1]  + suspended  sleep 1000
  [2]  - running    nohup sleep 2000

  $ bg %1 # run process 1 in the background
  [1]  - 18653 continued  sleep 1000

  $ jobs
  [1]  - running    sleep 1000
  [2]  + running    nohup sleep 2000

  $ kill -STOP %1 # stop process 1
  [1]  + 18653 suspended (signal)  sleep 1000

  $ jobs
  [1]  + suspended (signal)  sleep 1000
  [2]  - running    nohup sleep 2000

  $ kill -SIGHUP %1
  [1]  + 18653 hangup     sleep 1000

  $ jobs
  [2]  + running    nohup sleep 2000

  $ kill -SIGHUP %2

  $ jobs
  [2]  + running    nohup sleep 2000

  $ kill %2
  [2]  + 18745 terminated  nohup sleep 2000

  $ jobs

\end{lstlisting}


\subsection{Terminal Multiplexers - tmux}

\begin{description}
 \lstitem{tmux} terminal multiplexer that allows you to multiplex terminal windows using panes and tabs so that you can interact with multiple shell sessions
\end{description}

\begin{itemize}
 \item \lstinline{tmux} lets you manage shell sessions and is useful for remote machines since it eliminates the need to use \lstinline{nohup}
 \item \lstinline{tmux} uses keybindings of the form \lstinline{<C-b> x} (\lstinline{ctrl-b} release and another button \lstinline{x})
 \item Note: often remap \lstinline{<C-b>} to \lstinline{<C-a>} because it's faster and more ergonomic
\end{itemize}

\subsubsection{Sessions}
\begin{description}
 \item[session] an independent workspace with one or more windows
       \lstitem{tmux} starts a new session
       \lstitem{tmux new -s NAME} starts a session with that name
       \lstitem{tmux ls} lists the current sessions
       \lstitem{<C-b> d} detaches the current session
       \lstitem{tmux a} attaches the last session. You can use -t flag to specify which session to attach
\end{description}

\subsubsection{Windows}

\begin{description}
 \item[window] equivalent to tabs in editors or browsers
       \lstitem{C-b> c} creates a new window. To close it you can just terminate the shells doing \lstinline{<C-d>}
       \lstitem{<C-b> N} go to the N th window
       \lstitem{<C-b> p} goes to the previous window
       \lstitem{<C-b> n} goes to the next window
       \lstitem{<C-b> ,} rename the current window
       \lstitem{<C-b> w} list current windows
\end{description}

\subsubsection{Panes}
\begin{description}
 \item[pane] like vim splits, pane lets you have multiple shells in the same visual display
       \lstitem{<C-b> "} split the current pane horizontally
       \lstitem{<C-b> \%} split the current pane vertically
       \lstitem{<C-b> <direction>} move to the pane in the specified direction. Direction here means arrow keys.
       \lstitem{<C-b> z} toggle zoom for the current pane
       \lstitem{<C-b> [} start scrollback. You can then press \lstinline{<space>} to start a selection and \lstinline{<enter>} to copy that selection
       \lstitem{<C-b> <space>} cycle through pane arrangements
\end{description}

\subsection{Aliases}
\begin{description}
  \item[shell alias] a short form for another command that your shell will replace automatically for you
  \lstitem{alias alias_name="command_to_alias arg1 arg2"} command to create an alias. Note no spaces around equal sign \lstinline{=} because \lstinline{alias} only takes a single argument
\end{description}

\begin{lstlisting}
# Make shorthands for common flags
alias ll="ls -lh"

# Save a lot of typing for common commands
alias gs="git status"
alias gc="git commit"
alias v="vim"

# Save you from mistyping
alias sl=ls

# Overwrite existing commands for better defaults
alias mv="mv -i"           # -i prompts before overwrite
alias mkdir="mkdir -p"     # -p make parent dirs as needed
alias df="df -h"           # -h prints human readable format

# Alias can be composed
alias la="ls -A"
alias lla="la -l"

# To ignore an alias run it prepended with \
\ls
# Or disable an alias altogether with unalias
unalias la

# To get an alias definition just call it with alias
alias ll
# Will print ll='ls -lh'
\end{lstlisting}

\begin{itemize}
  \item Note: aliases do not persist shell sessions by default
  \item Need to add an alias to shell startup files like \lstinline{.bashrc} or \lstinline{.zshrc} to have it persist
\end{itemize}

\subsection{Dotfiles}

\begin{description}
  \item[dotfile] plain-text file whose file name starts with a \lstinline{.} (so that they are hidden in the directory listing \lstinline{ls} by default). Used to configure many programs (ex. \lstinline{~/.vimrc})
  \item[symlink] symbolic link a path to another path using \lstinline{ln}. Kinda like a pointer where you can specify one path that links to the path where the file actually is
\end{description}

\begin{lstlisting}
  # create a symlink
  ln -s path/to/file/you/want /symbolic/path/you/want
\end{lstlisting}

\begin{itemize}
  \item Shells are configured with dotfiles (ex. \lstinline{.bashrc}, \lstinline{.bash_profile}, \lstinline{.zshrc}) and reads these files to load its configuration on startup
  \item Can store environment variables in dotfiles
  \item Can add commands that you want to run on startup or modifications to your \lstinline{PATH} environment variable (usually required by programs so that their binaries can be found)
  \item For better organization, it's recommended to organize dotfiles in their own folder (under version control) and symlinked into place using a script
  \item This is done for easy installation on new machines, portability, synchronization, and change tracking
  \item Note: dotfiles need to be in home directory \lstinline{~/} (or use symlinks)
\end{itemize}

\subsubsection{Portability}

\begin{itemize}
  \item Dotfile configurations may not work on all machines (ex. diff OS or shells)
  \item Can then make specific configurations using if-statements (if supported by config file)
\end{itemize}

\begin{lstlisting}
  if [[ "$(uname)" == "Linux" ]]; then {do_something}; fi

  # Check before using shell-specific features
  if [[ "$SHELL" == "zsh" ]]; then {do_something}; fi

  # You can also make it machine-specific
  if [[ "$(hostname)" == "myServer" ]]; then {do_something};
\end{lstlisting}

\begin{itemize}
  \item If supported, also use includes for machine-specific settings (stored in another file)
\end{itemize}

\begin{lstlisting}
  [include]
    path = ~/.gitconfig_local
\end{lstlisting}

\begin{itemize}
  \item Can also share configurations across different programs
  \item ex. making both \lstinline{bash} and \lstinline{zsh} share the same set of aliases in \lstinline{.aliases}
\end{itemize}

\begin{lstlisting}
  # Test if ~/.aliases exists and source it
  if [ -f ~/.aliases ]; then
    source ~/.aliases
  fi
\end{lstlisting}

\subsection{Remote Machines}

\begin{description}
  \lstitem{ssh} Secure Shell (SSH) used to interact with a remote server/computer
\end{description}

\begin{lstlisting}
  # ssh into a server by running either
  ssh user@IP # ssh as user into server specified by this IP
  ssh user@URL # ssh as user into server specified by  this URL

  # Examples
  ssh foo@bar.mit.edu # user is foo, server is the URL
  ssh foobar@192.168.1.42 # user is foobar, server is the IP
\end{lstlisting}

\subsubsection{Executing Commands}
\begin{itemize}
  \item Can run commands directly with \lstinline{ssh}
  \item Also works with pipes to redirect input and output with local programs
\end{itemize}

\begin{lstlisting}
  # execute ls in the home folder of foobar
  ssh foobar@server ls

  # grep locally the remote output of ls
  ssh foobar@server ls | grep PATTERN

  # grep remotely the local output of ls
  ls | ssh foobar@server grep PATTERN
\end{lstlisting}

\subsubsection{SSH Keys}

\begin{itemize}
  \item Key-based authentication uses public-key cryptography to authenticate you to the server
  \item Allows you to avoid entering password every time
  \item Note: the secret private key (often \lstinline{~/.ssh/id_rsa} and more recently \lstinline{~/.ssh/id_ed25519}) is basically your password so treat it like so
\end{itemize}

\subsubsection{Key generation}

\begin{description}
  \lstitem{ssh-keygen} Generates a public and private key pair
  \lstitem{ssh-agent} lets you skip typing your passphrase every time
\end{description}

\begin{lstlisting}
  ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519
\end{lstlisting}

\begin{itemize}
  \item Recommended: use a passphrase to avoid someone who gets your private key to access authorized servers
\end{itemize}

\begin{lstlisting}
  # check if you have a passphrase and valid it
  ssh-keygen -y -f /path/to/key
\end{lstlisting}

\subsubsection{Key based authentication}
\begin{itemize}
  \item \lstinline{ssh} will look into \lstinline{.ssh/authorized_keys} (on the remote sever side) to determine which clients it should let in
\end{itemize}

\begin{lstlisting}
  # copy over your public key to .ssh/authorized_keys
  # on the remote server
  cat .ssh/id_ed25519.pub
    | ssh foobar@remote 'cat >> ~/.ssh/authorized_keys'

  # can also use ssh-copy-id if available
  ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote
\end{lstlisting}

\subsubsection{Copying files over SSH}
\begin{description}
  \lstitem{ssh+tee} use \lstinline{ssh} command execution and STDIN input. \lstinline{tree} then writes output from STDIN into a file
  \lstitem{scp} secure copy command useful for copying large amounts of files/directories (recurses over paths)
  \lstitem{rsync} improves upon \lstinline{scp} by detecting identical files in local and remote to avoid duplicate copying. Provides more control over symlinks, permission, and extra features like \lstinline{--partial} flag to resume a previously interrupted copy
\end{description}

\begin{lstlisting}
  # Copy a local file into a remote server file called serverfile
  # using ssh+tee
  cat localfile | ssh remote_server tee serverfile.

  # Copy a local file into a remote server file
  scp path/to/local_file remote_host:path/to/remote_file
\end{lstlisting}

\subsubsection{Port Forwarding}
\begin{itemize}
  \item Often have software that listens to specific ports in a machine to function
  \item ex. \lstinline{jupyter notebook}
  \item For local machines, you can just type the port \lstinline{localhost:PORT} or \lstinline{127.0.0.1:PORT}
  \item For remote servers, you need port forwarding (either Local Port Forwarding or Remote Port Forwarding)
\end{itemize}

\begin{description}
  \item[local port forwarding]: link a port in your local machine to the remote port for a service (forward local port)
  \item[remote port forwarding]: link a remote port to the local port for a service (forward remote port)
\end{description}

\begin{itemize}
  \item Usually use local port forwarding (ex. \lstinline{jupyter notebook})
\end{itemize}

\begin{lstlisting}
  # Execute jupyter notebook in remote server (listens to port 8888)
  # Want to interact with jupyter notebook locally so forward
  # the local port 9999 to the remote port 8888
  ssh -L 9999:localhost:8888 foobar@remote_server
  # Then navigate to localhost:9999 on local machine to use notebook
\end{lstlisting}

\subsubsection{Local Port Forwarding}

\begin{figure}[H]
  \includegraphics[width=160mm, scale=0.75]{pictures/local-port-forwarding.png}
  \caption{Local Port Forwarding}
\end{figure}

\subsubsection{Remote Port Forwarding}
\begin{figure}[H]
  \includegraphics[width=160mm, scale=0.75]{pictures/remote-port-forwarding.png}
  \caption{Remote Port Forwarding}
\end{figure}

\subsubsection{SSH Configuration}

\begin{description}
  \lstitem{\~/.ssh/config} Dotfile used to configure \lstinline{ssh}. Also readable by other programs like \lstinline{scp}, \lstinline{rsync}, etc that can convert the settings into the corresponding flags
  \lstitem{/etc/ssh/sshd_config} Used for server side configuration. Can make changes like disabling password authentication, changing ssh ports, enabling X11 forwarding, etc. Can also specify config settings on a per user basis
\end{description}

\begin{itemize}
  \item Note: \lstinline{~/.ssh/config} has some potentially private info that you might not want to share with other people
\end{itemize}

\subsubsection{Miscellaneous SSH Stuff}

\begin{description}
  \lstitem{mosh} mobile shell that improves upon \lstinline{ssh} by allowing roaming connections, intermittent connectivity, and providing intelligent local echo
  \lstitem{sshfs} mounts a folder on a remote server locally, allowing you to use a local editor
\end{description}

\subsection{Bash vs Zsh}
\begin{itemize}
  \item \lstinline{bash} is the most common shell and is the default option on most shells
\end{itemize}

\begin{description}
  \lstitem{zsh} a superset of \lstinline{bash} that provides extra features like
\end{description}

\begin{itemize}
  \item Smarter globbing, \lstinline{**}
  \item Inline globbing/wildcard expansion
  \item Spelling correction
  \item Better tab completion/selection
  \item Path expansion (\lstinline{cd /u/lo/b} expands to \lstinline{/usr/local/bin})
\end{itemize}


\end{document}
